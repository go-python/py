// Copyright 2015 The go-python Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bind

import (
	"fmt"
	"go/token"
	"strings"

	"golang.org/x/tools/go/types"
)

const (
	cPreamble = `/*
  C stubs for package py_%[1]s.
  gopy-gen -lang=python %[1]s

  File is generated by gopy-gen. Do not edit.
*/

#include "_cgo_export.h"

#include "Python.h"

/* stdlib */
#include <stdint.h>
#include <string.h>
#include <stddef.h>
#include <complex.h>

// helpers for CGo runtime

typedef struct { char *p; int n; } _cgopy_gostring_;
typedef struct { void* array; unsigned int len; unsigned int cap; } _cgopy_goslice_;


extern void crosscall2(void (*fn)(void *, int), void *, int);
extern void _cgo_allocate(void *, int);
extern void _cgo_panic(void *, int);

static void *_cgopy_goallocate(size_t len) {
  struct {
    size_t len;
    void *ret;
  } a;
  a.len = len;
  crosscall2(_cgo_allocate, &a, (int) sizeof a);
  return a.ret;
}

static void _cgopy_gopanic(const char *p) {
  struct {
    const char *p;
  } a;
  a.p = p;
  crosscall2(_cgo_panic, &a, (int) sizeof a);
}

static GoString _cgopy_makegostringn(const char *p, size_t l) {
  _cgopy_gostring_ ret;
  ret.p = (char*)_cgopy_goallocate(l + 1);
  memcpy(ret.p, p, l);
  ret.n = l;
  return *(GoString*)(&ret);
}

static GoString _cgopy_makegostring(const char *p) {
  _cgopy_gostring_ ret;
  size_t l;
  l = strlen(p);
  ret.p = (char*)_cgopy_goallocate(l);
  memcpy(ret.p, p, l);
  ret.n = l;
  return *(GoString*)(&ret);
}

static char* _cgopy_makecstring(const GoString *gostr) {
  _cgopy_gostring_ *s = (_cgopy_gostring_*)(gostr);
  char* cstr = (char*)malloc((s->n+1) * sizeof(char));
  memcpy(cstr, s->p, s->n);
  cstr[s->n] = '\0';
  return cstr;
}

`
)

type cpyGen struct {
	*printer

	fset *token.FileSet
	pkg  *types.Package
	err  ErrorList
}

func (g *cpyGen) gen() error {

	g.genPreamble()

	var funcs []string

	scope := g.pkg.Scope()
	names := scope.Names()
	for _, name := range names {
		obj := scope.Lookup(name)
		if !obj.Exported() {
			debugf("ignore %q (not exported)\n", name)
			continue
		}
		debugf("processing %q...\n", name)

		switch obj := obj.(type) {
		case *types.Const:
			// TODO(sbinet)
			panic(fmt.Errorf("not yet supported: %v (%T)", obj, obj))
		case *types.Var:
			// TODO(sbinet)
			panic(fmt.Errorf("not yet supported: %v (%T)", obj, obj))

		case *types.Func:
			funcs = append(funcs, obj.Name())
			g.genFunc(obj)

		case *types.TypeName:
			named := obj.Type().(*types.Named)
			switch typ := named.Underlying().(type) {
			case *types.Struct:
				// TODO(sbinet)
				panic(fmt.Errorf("not yet supported: %v (%T)", typ, obj))
			case *types.Interface:
				// TODO(sbinet)
				panic(fmt.Errorf("not yet supported: %v (%T)", typ, obj))
			default:
				// TODO(sbinet)
				panic(fmt.Errorf("not yet supported: %v (%T)", typ, obj))
			}

		default:
			// TODO(sbinet)
			panic(fmt.Errorf("not yet supported: %v (%T)", obj, obj))

		}
	}

	g.Printf("static PyMethodDef GoPy_%s_Methods[] = {\n", g.pkg.Name())
	g.Indent()
	for _, name := range funcs {
		//obj := scope.Lookup(name)
		g.Printf("{%[1]q, %[2]s, METH_VARARGS, %[3]q},\n",
			name, "gopy_"+name, "doc for: "+g.pkg.Name()+"."+name,
		)
	}
	g.Printf("{NULL, NULL, 0, NULL}        /* Sentinel */\n")
	g.Outdent()
	g.Printf("};\n\n")

	g.Printf("PyMODINIT_FUNC\ninit%[1]s(void)\n{\n", g.pkg.Name())
	g.Indent()
	g.Printf("(void) Py_InitModule3(%[1]q, GoPy_%[1]s_Methods, %[2]q);\n",
		g.pkg.Name(),
		"FIXME(sbinet): documentation for package "+g.pkg.Name(),
	)
	g.Outdent()
	g.Printf("}\n\n")

	if len(g.err) > 0 {
		return g.err
	}

	return nil
}

func (g *cpyGen) genFunc(o *types.Func) {

	g.Printf(`
/* pythonization of: %[2]s.%[1]s */
static PyObject*
gopy_%[1]s(PyObject *self, PyObject *args) {
`,
		o.Name(), g.pkg.Name(),
	)

	g.Indent()
	g.genFuncBody(o)
	g.Outdent()
	g.Printf("}\n\n")
}

func (g *cpyGen) genFuncBody(o *types.Func) {

	funcArgs := []string{}

	sig := o.Type().(*types.Signature)
	res := newVars(sig.Results())
	args := newVars(sig.Params())
	for _, arg := range args {
		arg.genDecl(g)
		funcArgs = append(funcArgs, arg.getFuncArg())
	}

	// FIXME(sbinet) pythonize (turn errors into python exceptions)
	if len(res) > 0 {
		switch len(res) {
		case 1:
			ret := res[0]
			ret.genRetDecl(g)
		default:
			g.Printf("struct %[1]s_return c_gopy_ret;\n", o.Name())
			/*
					for i := 0; i < res.Len(); i++ {
						ret := res.At(i)
						n := ret.Name()
						if n == "" {
							n = "gopy_" + strconv.Itoa(i)
						}
						g.Printf("%[1]s c_%[2]s;\n", ctypeName(ret.Type()), n)
				    }
			*/
		}
	}

	g.Printf("\n")

	if len(args) > 0 {
		g.Printf("if (!PyArg_ParseTuple(args, ")
		format := []string{}
		pyaddrs := []string{}
		for _, arg := range args {
			pyfmt, addr := arg.getArgParse()
			format = append(format, pyfmt)
			pyaddrs = append(pyaddrs, addr)
		}
		g.Printf("%q, %s)) {\n", strings.Join(format, ""), strings.Join(pyaddrs, ", "))
		g.Indent()
		g.Printf("return NULL;\n")
		g.Outdent()
		g.Printf("}\n\n")
	}

	if len(args) > 0 {
		for _, arg := range args {
			arg.genFuncPreamble(g)
		}
		g.Printf("\n")
	}

	if len(res) > 0 {
		g.Printf("c_gopy_ret = ")
	}

	g.Printf("GoPy_%[1]s(%[2]s);\n", o.Name(), strings.Join(funcArgs, ", "))

	g.Printf("\n")

	if len(res) <= 0 {
		g.Printf("Py_INCREF(Py_None);\nreturn Py_None;\n")
		return
	}

	format := []string{}
	funcArgs = []string{}
	switch len(res) {
	case 1:
		ret := res[0]
		pyfmt, _ := ret.getArgParse()
		format = append(format, pyfmt)
		funcArgs = append(funcArgs, "c_gopy_ret")
	default:
		for _, ret := range res {
			pyfmt, _ := ret.getArgParse()
			format = append(format, pyfmt)
			funcArgs = append(funcArgs, ret.getFuncArg())
		}
	}

	g.Printf("return Py_BuildValue(%q, %s);\n",
		strings.Join(format, ""),
		strings.Join(funcArgs, ", "),
	)
	//g.Printf("return NULL;\n")
}

func (g *cpyGen) genPreamble() {
	n := g.pkg.Name()
	g.Printf(cPreamble, n, g.pkg.Path())
}
