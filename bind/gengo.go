// Copyright 2015 The go-python Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bind

import (
	"fmt"
	"go/token"
	"strings"

	"golang.org/x/tools/go/types"
)

const (
	goPreamble = `// Package py_%[1]s is an autogenerated binder stub for package %[1]s.
// gopy-gen -lang=go %[1]s
//
// File is generated by gopy-gen. Do not edit.
package py_%[1]s

// void init%[1]s(void);
import "C"

import (
	%[2]q
)

`
)

type goGen struct {
	*printer

	fset *token.FileSet
	pkg  *types.Package
	err  ErrorList
}

func (g *goGen) gen() error {

	g.genPreamble()

	var funcs []string

	scope := g.pkg.Scope()
	names := scope.Names()
	for _, name := range names {
		obj := scope.Lookup(name)
		if !obj.Exported() {
			debugf("ignore %q (not exported)\n", name)
			continue
		}
		debugf("processing %q...\n", name)

		switch obj := obj.(type) {
		case *types.Const:
			// TODO(sbinet)
			panic(fmt.Errorf("not yet supported: %v (%T)", obj, obj))
		case *types.Var:
			// TODO(sbinet)
			panic(fmt.Errorf("not yet supported: %v (%T)", obj, obj))

		case *types.Func:
			funcs = append(funcs, obj.Name())
			g.genFunc(obj)

		case *types.TypeName:
			named := obj.Type().(*types.Named)
			switch typ := named.Underlying().(type) {
			case *types.Struct:
				// TODO(sbinet)
				panic(fmt.Errorf("not yet supported: %v (%T)", typ, obj))
			case *types.Interface:
				// TODO(sbinet)
				panic(fmt.Errorf("not yet supported: %v (%T)", typ, obj))
			default:
				// TODO(sbinet)
				panic(fmt.Errorf("not yet supported: %v (%T)", typ, obj))
			}

		default:
			// TODO(sbinet)
			panic(fmt.Errorf("not yet supported: %v (%T)", obj, obj))

		}
	}

	g.Printf("// Import imports the generated CPython module\nfunc Import() {\n")
	g.Indent()
	g.Printf("C.init%[1]s()\n", g.pkg.Name())
	g.Outdent()
	g.Printf("}\n")

	if len(g.err) > 0 {
		return g.err
	}

	return nil
}

func (g *goGen) genFunc(o *types.Func) {
	sig := o.Type().(*types.Signature)
	args := sig.Params()
	res := sig.Results()

	g.Printf(`
//export GoPy_%[1]s
// GoPy_%[1]s wraps %[2]s.%[1]s
// %[3]s
// %[4]v
// %[5]v
// %[6]v
func GoPy_%[1]s%[7]v {
`,
		o.Name(), g.pkg.Name(), o.FullName(),
		sig, args, res,
		strings.TrimLeft(sig.String(), "func "),
	)

	g.Indent()
	g.genFuncBody(o)
	g.Outdent()
	g.Printf("}\n\n")
}

func (g *goGen) genFuncBody(o *types.Func) {

	sig := o.Type().(*types.Signature)
	ret := ""
	if sig.Results().Len() > 0 {
		ret = "return "
	}

	g.Printf(
		"%[3]s%[1]s.%[2]s(",
		g.pkg.Name(),
		o.Name(),
		ret,
	)

	args := sig.Params()
	for i := 0; i < args.Len(); i++ {
		arg := args.At(i)
		tail := ""
		if i+1 < args.Len() {
			tail = ", "
		}
		g.Printf("%s%s", arg.Name(), tail)
	}
	g.Printf(")\n")

}

func (g *goGen) genPreamble() {
	n := g.pkg.Name()
	g.Printf(goPreamble, n, g.pkg.Path())
}
